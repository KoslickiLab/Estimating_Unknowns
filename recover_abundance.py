import numpy as np
import cvxpy as cp
import pandas as pd
import csv
import sample_vector as sv
import compute_weight as cw
from scipy.sparse import load_npz
import argparse
import utils
import warnings
warnings.filterwarnings("ignore")


# inputs: matrix A, vector y, weight w
# output: estimate vector x and metadata
def recover_abundance_from_vectors(A, y, w):
    """
    Runs the linear program for quantile regression with weight w on the equation Ax = y.
    :param A: matrix (reference database)
    :param y: vector (sample kmer counts)
    :param w: False positive weight
    :return: vector x (estimated organism counts)
    """
    K, N = np.shape(A)
    x = cp.Variable(N)
    u = cp.Variable(K)
    v = cp.Variable(K)
    tau = 1 / (w + 1)
    ones_K = np.ones(K)
    objective = cp.Minimize(
        tau * (ones_K @ u) + (1 - tau) * (ones_K @ v)
    )
    constraints = [
        x >= 0,
        u >= 0,
        v >= 0,
        u - v + (A @ x) == y,
    ]
    prob = cp.Problem(objective, constraints)
    result = prob.solve(solver=cp.SCIPY, verbose=False)
    return x.value


def load_reference_metadata(
    matrix_file,
    ksize,
):
    prefix = args.ref_file.split('ref_matrix_processed.npz')[0]
    hash_to_idx_file = prefix + 'hash_to_col_idx.csv'
    processed_org_file = prefix + 'processed_org_idx.csv'
    
    reference_matrix = load_npz(matrix_file)
    hash_to_idx = utils.load_hashes(hash_to_idx_file)
    organism_data = pd.read_csv(processed_org_file)
    
    return reference_matrix, hash_to_idx, hash_to_idx_file, organism_data


def recover_abundance_data(
    ref_matrix,
    sample_vector,
    ref_organism_data,
    ksize,
    p_val,
    num_kmers_quantile,
    total_sample_kmers,
    w=None,
):
    recov_org_data = ref_organism_data.copy()
    recov_org_data['estimated_sample_kmers'] = total_sample_kmers
    est_num_genomes = np.round(total_sample_kmers / np.mean(recov_org_data['estimated_total_kmers']))
    recov_org_data['estimated_num_genomes'] = est_num_genomes
    
    if w is None:
        num_kmers_for_pval = int(np.quantile(recov_org_data['num_kmers'], num_kmers_quantile))
        recov_org_data['num_kmers_for_pval'] = num_kmers_for_pval
        w, min_quantile = cw.compute_weight(ksize, num_kmers_for_pval, p_val = p_val, mut_thresh = 0.05, est_num_genomes = est_num_genomes)
        recov_org_data['unmutated_kmer_threshold'] = min_quantile
    else:
        warnings.warn('w set manually; specified p_val overriden.')
    recov_org_data['w'] = w
    
    abundance = recover_abundance_from_vectors(ref_matrix, sample_vector, w)
    recov_org_data['count_abundance'] = abundance
    recov_org_data['relative_abundance'] = abundance * recov_org_data['estimated_total_kmers']/total_sample_kmers
    return recov_org_data


def recover_abundance_from_files(
    matrix_file,
    sample_file,
    ksize,
    p_val,
    num_kmers_quantile,
    output_filename=None,
    w=None
):
    """
    Runs linear program for unknown estimation off of files generated by ref_matrix.py and creates human-readable results file.
    :param matrix_file: location of ref_matrix_processed.npz file (A matrix)
    :param sample_file: location of sample.sig file (y vector)
    :param ksize: kmer size
    :param p_val: maximum probability of at least one false negative in the sample.
    :param num_kmers_quantile: quantile for determining representative number of kmers in sketch to be used in calculation of p-value.
    :param output_filename: destination for results file; if blank, no file will be written
    :param w: false positive weight. Optional; if set, overrides p_val.
    :return: pandas dataframe containing recovered abundances and metadata.
    """
    (
        reference_matrix,
        hash_to_idx,
        hash_to_idx_file,
        organism_data
    ) = load_reference_metadata(matrix_file, ksize)
    
    sample_vector, sample_sig = sv.sample_vector_from_files(sample_file, hash_to_idx_file, ksize)
    total_sample_kmers = utils.total_kmers_est(sample_sig)

    recov_org_data = recover_abundance_data(
        reference_matrix,
        sample_vector,
        organism_data,
        ksize,
        p_val,
        num_kmers_quantile,
        total_sample_kmers,
        w=w,
    )
    
    if output_filename:
        recov_org_data.to_csv(output_filename)
    return recov_org_data


if __name__ == "__main__":
    parser = argparse.ArgumentParser(
        description="This script estimates the abundance of microorganisms from a reference database matrix and metagenomic sample.",
        formatter_class=argparse.ArgumentDefaultsHelpFormatter)
    parser.add_argument('--ref_file', help='Reference database matrix in npz format', required=True)
    parser.add_argument('--ksize', type=int, help='Size of kmers used in sketch', required=True)
    parser.add_argument('--sample_file', help='Metagenomic sample in .sig format', required=True)
    parser.add_argument('--w', type=float, help='False positive weight. If set manually, overrides p_val argument.', required=False, default = None)
    parser.add_argument('--p_val', type=float, help='Maximum probability of at least one false negative in the sample.', required=False, default = 0.01)
    parser.add_argument('--num_kmers_quantile', type=float, help='To compute false negative p-val, assume each organism has constant number of kmers in the sketch given by this quantile of the actual kmer counts.', required=False, default = 0.33)
    parser.add_argument('--outfile', help='csv destination for results', required=True)
    args = parser.parse_args()
    
    recover_abundance_from_files(args.ref_file, args.sample_file, args.ksize, args.p_val, args.num_kmers_quantile, args.outfile, w = args.w)
